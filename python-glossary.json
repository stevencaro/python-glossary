[
{"term": ">>>", "gloss": "The default Python prompt of the interactive shell.  Often seen for code\nexamples which can be executed interactively in the interpreter."},
{"term": "...", "gloss": "The default Python prompt of the interactive shell when entering code for\nan indented code block or within a pair of matching left and right\ndelimiters (parentheses, square brackets or curly braces)."},
{"term": "2to3", "gloss": "A tool that tries to convert Python 2.x code to Python 3.x code by\nhandling most of the incompatibilities which can be detected by parsing the\nsource and traversing the parse tree.\n2to3 is available in the standard library as lib2to3; a standalone\nentry point is provided as Tools/scripts/2to3.  See\n2to3 - Automated Python 2 to 3 code translation.\n"},
{"term": "abstract base class", "gloss": "Abstract base classes complement duck-typing by\nproviding a way to define interfaces when other techniques like\nhasattr() would be clumsy or subtly wrong (for example with\nmagic methods).  ABCs introduce virtual\nsubclasses, which are classes that don’t inherit from a class but are\nstill recognized by isinstance() and issubclass(); see the\nabc module documentation.  Python comes with many built-in ABCs for\ndata structures (in the collections.abc module), numbers (in the\nnumbers module), streams (in the io module), import finders\nand loaders (in the importlib.abc module).  You can create your own\nABCs with the abc module."},
{"term": "argument", "gloss": "A value passed to a function (or method) when calling the\nfunction.  There are two kinds of argument:\n\nkeyword argument: an argument preceded by an identifier (e.g.\nname=) in a function call or passed as a value in a dictionary\npreceded by **.  For example, 3 and 5 are both keyword\narguments in the following calls to complex():\ncomplex(real=3, imag=5)\ncomplex(**{'real': 3, 'imag': 5})\n\n\n\npositional argument: an argument that is not a keyword argument.\nPositional arguments can appear at the beginning of an argument list\nand/or be passed as elements of an iterable preceded by *.\nFor example, 3 and 5 are both positional arguments in the\nfollowing calls:\ncomplex(3, 5)\ncomplex(*(3, 5))\n\n\n\n\nArguments are assigned to the named local variables in a function body.\nSee the Calls section for the rules governing this assignment.\nSyntactically, any expression can be used to represent an argument; the\nevaluated value is assigned to the local variable.\nSee also the parameter glossary entry, the FAQ question on\nthe difference between arguments and parameters, and PEP 362.\n"},
{"term": "asynchronous context manager", "gloss": "An object which controls the environment seen in an\nasync with statement by defining __aenter__() and\n__aexit__() methods.  Introduced by PEP 492."},
{"term": "asynchronous generator", "gloss": "A function which returns an asynchronous generator iterator.  It\nlooks like a coroutine function defined with async def except\nthat it contains yield expressions for producing a series of\nvalues usable in an async for loop.\nUsually refers to a asynchronous generator function, but may refer to an\nasynchronous generator iterator in some contexts.  In cases where the\nintended meaning isn’t clear, using the full terms avoids ambiguity.\nAn asynchronous generator function may contain await\nexpressions as well as async for, and async with\nstatements.\n"},
{"term": "asynchronous generator iterator", "gloss": "An object created by a asynchronous generator function.\nThis is an asynchronous iterator which when called using the\n__anext__() method returns an awaitable object which will execute\nthat the body of the asynchronous generator function until the\nnext yield expression.\nEach yield temporarily suspends processing, remembering the\nlocation execution state (including local variables and pending\ntry-statements).  When the asynchronous generator iterator effectively\nresumes with another awaitable returned by __anext__(), it\npicks-up where it left-off.  See PEP 492 and PEP 525.\n"},
{"term": "asynchronous iterable", "gloss": "An object, that can be used in an async for statement.\nMust return an asynchronous iterator from its\n__aiter__() method.  Introduced by PEP 492."},
{"term": "asynchronous iterator", "gloss": "An object that implements __aiter__() and __anext__()\nmethods.  __anext__ must return an awaitable object.\nasync for resolves awaitable returned from asynchronous\niterator’s __anext__() method until it raises\nStopAsyncIteration exception.  Introduced by PEP 492."},
{"term": "attribute", "gloss": "A value associated with an object which is referenced by name using\ndotted expressions.  For example, if an object o has an attribute\na it would be referenced as o.a."},
{"term": "awaitable", "gloss": "An object that can be used in an await expression.  Can be\na coroutine or an object with an __await__() method.\nSee also PEP 492."},
{"term": "BDFL", "gloss": "Benevolent Dictator For Life, a.k.a. Guido van Rossum, Python’s creator."},
{"term": "binary file", "gloss": "A file object able to read and write\nbytes-like objects.\nExamples of binary files are files opened in binary mode ('rb',\n'wb' or 'rb+'), sys.stdin.buffer,\nsys.stdout.buffer, and instances of io.BytesIO and\ngzip.GzipFile.\n\nSee also\nA text file reads and writes str objects.\n\n"},
{"term": "bytes-like object", "gloss": "An object that supports the Buffer Protocol and can\nexport a C-contiguous buffer. This includes all bytes,\nbytearray, and array.array objects, as well as many\ncommon memoryview objects.  Bytes-like objects can\nbe used for various operations that work with binary data; these include\ncompression, saving to a binary file, and sending over a socket.\nSome operations need the binary data to be mutable.  The documentation\noften refers to these as “read-write bytes-like objects”.  Example\nmutable buffer objects include bytearray and a\nmemoryview of a bytearray.\nOther operations require the binary data to be stored in\nimmutable objects (“read-only bytes-like objects”); examples\nof these include bytes and a memoryview\nof a bytes object.\n"},
{"term": "bytecode", "gloss": "Python source code is compiled into bytecode, the internal representation\nof a Python program in the CPython interpreter.  The bytecode is also\ncached in .pyc files so that executing the same file is\nfaster the second time (recompilation from source to bytecode can be\navoided).  This “intermediate language” is said to run on a\nvirtual machine that executes the machine code corresponding to\neach bytecode. Do note that bytecodes are not expected to work between\ndifferent Python virtual machines, nor to be stable between Python\nreleases.\nA list of bytecode instructions can be found in the documentation for\nthe dis module.\n"},
{"term": "class", "gloss": "A template for creating user-defined objects. Class definitions\nnormally contain method definitions which operate on instances of the\nclass."},
{"term": "coercion", "gloss": "The implicit conversion of an instance of one type to another during an\noperation which involves two arguments of the same type.  For example,\nint(3.15) converts the floating point number to the integer 3, but\nin 3+4.5, each argument is of a different type (one int, one float),\nand both must be converted to the same type before they can be added or it\nwill raise a TypeError.  Without coercion, all arguments of even\ncompatible types would have to be normalized to the same value by the\nprogrammer, e.g., float(3)+4.5 rather than just 3+4.5."},
{"term": "complex number", "gloss": "An extension of the familiar real number system in which all numbers are\nexpressed as a sum of a real part and an imaginary part.  Imaginary\nnumbers are real multiples of the imaginary unit (the square root of\n-1), often written i in mathematics or j in\nengineering.  Python has built-in support for complex numbers, which are\nwritten with this latter notation; the imaginary part is written with a\nj suffix, e.g., 3+1j.  To get access to complex equivalents of the\nmath module, use cmath.  Use of complex numbers is a fairly\nadvanced mathematical feature.  If you’re not aware of a need for them,\nit’s almost certain you can safely ignore them."},
{"term": "context manager", "gloss": "An object which controls the environment seen in a with\nstatement by defining __enter__() and __exit__() methods.\nSee PEP 343."},
{"term": "contiguous", "gloss": "A buffer is considered contiguous exactly if it is either\nC-contiguous or Fortran contiguous.  Zero-dimensional buffers are\nC and Fortran contiguous.  In one-dimensional arrays, the items\nmust be laid out in memory next to each other, in order of\nincreasing indexes starting from zero.  In multidimensional\nC-contiguous arrays, the last index varies the fastest when\nvisiting items in order of memory address.  However, in\nFortran contiguous arrays, the first index varies the fastest.\n"},
{"term": "coroutine", "gloss": "Coroutines is a more generalized form of subroutines. Subroutines are\nentered at one point and exited at another point.  Coroutines can be\nentered, exited, and resumed at many different points.  They can be\nimplemented with the async def statement.  See also\nPEP 492."},
{"term": "coroutine function", "gloss": "A function which returns a coroutine object.  A coroutine\nfunction may be defined with the async def statement,\nand may contain await, async for, and\nasync with keywords.  These were introduced\nby PEP 492."},
{"term": "CPython", "gloss": "The canonical implementation of the Python programming language, as\ndistributed on python.org.  The term “CPython”\nis used when necessary to distinguish this implementation from others\nsuch as Jython or IronPython."},
{"term": "decorator", "gloss": "A function returning another function, usually applied as a function\ntransformation using the @wrapper syntax.  Common examples for\ndecorators are classmethod() and staticmethod().\nThe decorator syntax is merely syntactic sugar, the following two\nfunction definitions are semantically equivalent:\ndef f(...):\n    ...\nf = staticmethod(f)\n\n@staticmethod\ndef f(...):\n    ...\n\n\nThe same concept exists for classes, but is less commonly used there.  See\nthe documentation for function definitions and\nclass definitions for more about decorators.\n"},
{"term": "descriptor", "gloss": "Any object which defines the methods __get__(), __set__(), or\n__delete__().  When a class attribute is a descriptor, its special\nbinding behavior is triggered upon attribute lookup.  Normally, using\na.b to get, set or delete an attribute looks up the object named b in\nthe class dictionary for a, but if b is a descriptor, the respective\ndescriptor method gets called.  Understanding descriptors is a key to a\ndeep understanding of Python because they are the basis for many features\nincluding functions, methods, properties, class methods, static methods,\nand reference to super classes.\nFor more information about descriptors’ methods, see Implementing Descriptors.\n"},
{"term": "dictionary", "gloss": "An associative array, where arbitrary keys are mapped to values.  The\nkeys can be any object with __hash__() and __eq__() methods.\nCalled a hash in Perl."},
{"term": "dictionary view", "gloss": "The objects returned from dict.keys(), dict.values(), and\ndict.items() are called dictionary views. They provide a dynamic\nview on the dictionary’s entries, which means that when the dictionary\nchanges, the view reflects these changes. To force the\ndictionary view to become a full list use list(dictview).  See\nDictionary view objects."},
{"term": "docstring", "gloss": "A string literal which appears as the first expression in a class,\nfunction or module.  While ignored when the suite is executed, it is\nrecognized by the compiler and put into the __doc__ attribute\nof the enclosing class, function or module.  Since it is available via\nintrospection, it is the canonical place for documentation of the\nobject."},
{"term": "duck-typing", "gloss": "A programming style which does not look at an object’s type to determine\nif it has the right interface; instead, the method or attribute is simply\ncalled or used (“If it looks like a duck and quacks like a duck, it\nmust be a duck.”)  By emphasizing interfaces rather than specific types,\nwell-designed code improves its flexibility by allowing polymorphic\nsubstitution.  Duck-typing avoids tests using type() or\nisinstance().  (Note, however, that duck-typing can be complemented\nwith abstract base classes.)  Instead, it\ntypically employs hasattr() tests or EAFP programming."},
{"term": "EAFP", "gloss": "Easier to ask for forgiveness than permission.  This common Python coding\nstyle assumes the existence of valid keys or attributes and catches\nexceptions if the assumption proves false.  This clean and fast style is\ncharacterized by the presence of many try and except\nstatements.  The technique contrasts with the LBYL style\ncommon to many other languages such as C."},
{"term": "expression", "gloss": "A piece of syntax which can be evaluated to some value.  In other words,\nan expression is an accumulation of expression elements like literals,\nnames, attribute access, operators or function calls which all return a\nvalue.  In contrast to many other languages, not all language constructs\nare expressions.  There are also statements which cannot be used\nas expressions, such as if.  Assignments are also statements,\nnot expressions."},
{"term": "extension module", "gloss": "A module written in C or C++, using Python’s C API to interact with the\ncore and with user code."},
{"term": "f-string", "gloss": "String literals prefixed with 'f' or 'F' are commonly called\n“f-strings” which is short for\nformatted string literals.  See also PEP 498."},
{"term": "file object", "gloss": "An object exposing a file-oriented API (with methods such as\nread() or write()) to an underlying resource.  Depending\non the way it was created, a file object can mediate access to a real\non-disk file or to another type of storage or communication device\n(for example standard input/output, in-memory buffers, sockets, pipes,\netc.).  File objects are also called file-like objects or\nstreams.\nThere are actually three categories of file objects: raw\nbinary files, buffered\nbinary files and text files.\nTheir interfaces are defined in the io module.  The canonical\nway to create a file object is by using the open() function.\n"},
{"term": "file-like object", "gloss": "A synonym for file object."},
{"term": "finder", "gloss": "An object that tries to find the loader for a module that is\nbeing imported.\nSince Python 3.3, there are two types of finder: meta path finders for use with sys.meta_path, and path\nentry finders for use with sys.path_hooks.\nSee PEP 302, PEP 420 and PEP 451 for much more detail.\n"},
{"term": "floor division", "gloss": "Mathematical division that rounds down to nearest integer.  The floor\ndivision operator is //.  For example, the expression 11 // 4\nevaluates to 2 in contrast to the 2.75 returned by float true\ndivision.  Note that (-11) // 4 is -3 because that is -2.75\nrounded downward. See PEP 238."},
{"term": "function", "gloss": "A series of statements which returns some value to a caller. It can also\nbe passed zero or more arguments which may be used in\nthe execution of the body. See also parameter, method,\nand the Function definitions section."},
{"term": "function annotation", "gloss": "An arbitrary metadata value associated with a function parameter or return\nvalue. Its syntax is explained in section Function definitions.  Annotations\nmay be accessed via the __annotations__ special attribute of a\nfunction object.\nPython itself does not assign any particular meaning to function\nannotations. They are intended to be interpreted by third-party libraries\nor tools.  See PEP 3107, which describes some of their potential uses.\n"},
{"term": "__future__", "gloss": "A pseudo-module which programmers can use to enable new language features\nwhich are not compatible with the current interpreter.\nBy importing the __future__ module and evaluating its variables,\nyou can see when a new feature was first added to the language and when it\nbecomes the default:\n>>> import __future__\n>>> __future__.division\n_Feature((2, 2, 0, 'alpha', 2), (3, 0, 0, 'alpha', 0), 8192)\n\n\n"},
{"term": "garbage collection", "gloss": "The process of freeing memory when it is not used anymore.  Python\nperforms garbage collection via reference counting and a cyclic garbage\ncollector that is able to detect and break reference cycles.  The\ngarbage collector can be controlled using the gc module."},
{"term": "generator", "gloss": "A function which returns a generator iterator.  It looks like a\nnormal function except that it contains yield expressions\nfor producing a series of values usable in a for-loop or that can be\nretrieved one at a time with the next() function.\nUsually refers to a generator function, but may refer to a\ngenerator iterator in some contexts.  In cases where the intended\nmeaning isn’t clear, using the full terms avoids ambiguity.\n"},
{"term": "generator iterator", "gloss": "An object created by a generator function.\nEach yield temporarily suspends processing, remembering the\nlocation execution state (including local variables and pending\ntry-statements).  When the generator iterator resumes, it picks-up where\nit left-off (in contrast to functions which start fresh on every\ninvocation).\n"},
{"term": "generator expression", "gloss": "An expression that returns an iterator.  It looks like a normal expression\nfollowed by a for expression defining a loop variable, range,\nand an optional if expression.  The combined expression\ngenerates values for an enclosing function:\n>>> sum(i*i for i in range(10))         # sum of squares 0, 1, 4, ... 81\n285\n\n\n"},
{"term": "generic function", "gloss": "A function composed of multiple functions implementing the same operation\nfor different types. Which implementation should be used during a call is\ndetermined by the dispatch algorithm.\nSee also the single dispatch glossary entry, the\nfunctools.singledispatch() decorator, and PEP 443.\n"},
{"term": "GIL", "gloss": "See global interpreter lock."},
{"term": "global interpreter lock", "gloss": "The mechanism used by the CPython interpreter to assure that\nonly one thread executes Python bytecode at a time.\nThis simplifies the CPython implementation by making the object model\n(including critical built-in types such as dict) implicitly\nsafe against concurrent access.  Locking the entire interpreter\nmakes it easier for the interpreter to be multi-threaded, at the\nexpense of much of the parallelism afforded by multi-processor\nmachines.\nHowever, some extension modules, either standard or third-party,\nare designed so as to release the GIL when doing computationally-intensive\ntasks such as compression or hashing.  Also, the GIL is always released\nwhen doing I/O.\nPast efforts to create a “free-threaded” interpreter (one which locks\nshared data at a much finer granularity) have not been successful\nbecause performance suffered in the common single-processor case. It\nis believed that overcoming this performance issue would make the\nimplementation much more complicated and therefore costlier to maintain.\n"},
{"term": "hashable", "gloss": "An object is hashable if it has a hash value which never changes during\nits lifetime (it needs a __hash__() method), and can be compared to\nother objects (it needs an __eq__() method).  Hashable objects which\ncompare equal must have the same hash value.\nHashability makes an object usable as a dictionary key and a set member,\nbecause these data structures use the hash value internally.\nAll of Python’s immutable built-in objects are hashable; mutable\ncontainers (such as lists or dictionaries) are not.  Objects which are\ninstances of user-defined classes are hashable by default.  They all\ncompare unequal (except with themselves), and their hash value is derived\nfrom their id().\n"},
{"term": "IDLE", "gloss": "An Integrated Development Environment for Python.  IDLE is a basic editor\nand interpreter environment which ships with the standard distribution of\nPython."},
{"term": "immutable", "gloss": "An object with a fixed value.  Immutable objects include numbers, strings and\ntuples.  Such an object cannot be altered.  A new object has to\nbe created if a different value has to be stored.  They play an important\nrole in places where a constant hash value is needed, for example as a key\nin a dictionary."},
{"term": "import path", "gloss": "A list of locations (or path entries) that are\nsearched by the path based finder for modules to import. During\nimport, this list of locations usually comes from sys.path, but\nfor subpackages it may also come from the parent package’s __path__\nattribute."},
{"term": "importing", "gloss": "The process by which Python code in one module is made available to\nPython code in another module."},
{"term": "importer", "gloss": "An object that both finds and loads a module; both a\nfinder and loader object."},
{"term": "interactive", "gloss": "Python has an interactive interpreter which means you can enter\nstatements and expressions at the interpreter prompt, immediately\nexecute them and see their results.  Just launch python with no\narguments (possibly by selecting it from your computer’s main\nmenu). It is a very powerful way to test out new ideas or inspect\nmodules and packages (remember help(x))."},
{"term": "interpreted", "gloss": "Python is an interpreted language, as opposed to a compiled one,\nthough the distinction can be blurry because of the presence of the\nbytecode compiler.  This means that source files can be run directly\nwithout explicitly creating an executable which is then run.\nInterpreted languages typically have a shorter development/debug cycle\nthan compiled ones, though their programs generally also run more\nslowly.  See also interactive."},
{"term": "interpreter shutdown", "gloss": "When asked to shut down, the Python interpreter enters a special phase\nwhere it gradually releases all allocated resources, such as modules\nand various critical internal structures.  It also makes several calls\nto the garbage collector. This can trigger\nthe execution of code in user-defined destructors or weakref callbacks.\nCode executed during the shutdown phase can encounter various\nexceptions as the resources it relies on may not function anymore\n(common examples are library modules or the warnings machinery).\nThe main reason for interpreter shutdown is that the __main__ module\nor the script being run has finished executing.\n"},
{"term": "iterable", "gloss": "An object capable of returning its members one at a time. Examples of\niterables include all sequence types (such as list, str,\nand tuple) and some non-sequence types like dict,\nfile objects, and objects of any classes you define\nwith an __iter__() method or with a __getitem__() method\nthat implements Sequence semantics.\nIterables can be\nused in a for loop and in many other places where a sequence is\nneeded (zip(), map(), …).  When an iterable object is passed\nas an argument to the built-in function iter(), it returns an\niterator for the object.  This iterator is good for one pass over the set\nof values.  When using iterables, it is usually not necessary to call\niter() or deal with iterator objects yourself.  The for\nstatement does that automatically for you, creating a temporary unnamed\nvariable to hold the iterator for the duration of the loop.  See also\niterator, sequence, and generator.\n"},
{"term": "iterator", "gloss": "An object representing a stream of data.  Repeated calls to the iterator’s\n__next__() method (or passing it to the built-in function\nnext()) return successive items in the stream.  When no more data\nare available a StopIteration exception is raised instead.  At this\npoint, the iterator object is exhausted and any further calls to its\n__next__() method just raise StopIteration again.  Iterators\nare required to have an __iter__() method that returns the iterator\nobject itself so every iterator is also iterable and may be used in most\nplaces where other iterables are accepted.  One notable exception is code\nwhich attempts multiple iteration passes.  A container object (such as a\nlist) produces a fresh new iterator each time you pass it to the\niter() function or use it in a for loop.  Attempting this\nwith an iterator will just return the same exhausted iterator object used\nin the previous iteration pass, making it appear like an empty container.\nMore information can be found in Iterator Types.\n"},
{"term": "key function", "gloss": "A key function or collation function is a callable that returns a value\nused for sorting or ordering.  For example, locale.strxfrm() is\nused to produce a sort key that is aware of locale specific sort\nconventions.\nA number of tools in Python accept key functions to control how elements\nare ordered or grouped.  They include min(), max(),\nsorted(), list.sort(), heapq.merge(),\nheapq.nsmallest(), heapq.nlargest(), and\nitertools.groupby().\nThere are several ways to create a key function.  For example. the\nstr.lower() method can serve as a key function for case insensitive\nsorts.  Alternatively, a key function can be built from a\nlambda expression such as lambda r: (r[0], r[2]).  Also,\nthe operator module provides three key function constructors:\nattrgetter(), itemgetter(), and\nmethodcaller().  See the Sorting HOW TO for examples of how to create and use key functions.\n"},
{"term": "keyword argument", "gloss": "See argument."},
{"term": "lambda", "gloss": "An anonymous inline function consisting of a single expression\nwhich is evaluated when the function is called.  The syntax to create\na lambda function is lambda [arguments]: expression"},
{"term": "LBYL", "gloss": "Look before you leap.  This coding style explicitly tests for\npre-conditions before making calls or lookups.  This style contrasts with\nthe EAFP approach and is characterized by the presence of many\nif statements.\nIn a multi-threaded environment, the LBYL approach can risk introducing a\nrace condition between “the looking” and “the leaping”.  For example, the\ncode, if key in mapping: return mapping[key] can fail if another\nthread removes key from mapping after the test, but before the lookup.\nThis issue can be solved with locks or by using the EAFP approach.\n"},
{"term": "list", "gloss": "A built-in Python sequence.  Despite its name it is more akin\nto an array in other languages than to a linked list since access to\nelements are O(1)."},
{"term": "list comprehension", "gloss": "A compact way to process all or part of the elements in a sequence and\nreturn a list with the results.  result = ['{:#04x}'.format(x) for x in\nrange(256) if x % 2 == 0] generates a list of strings containing\neven hex numbers (0x..) in the range from 0 to 255. The if\nclause is optional.  If omitted, all elements in range(256) are\nprocessed."},
{"term": "loader", "gloss": "An object that loads a module. It must define a method named\nload_module(). A loader is typically returned by a\nfinder. See PEP 302 for details and\nimportlib.abc.Loader for an abstract base class."},
{"term": "mapping", "gloss": "A container object that supports arbitrary key lookups and implements the\nmethods specified in the Mapping or\nMutableMapping\nabstract base classes.  Examples\ninclude dict, collections.defaultdict,\ncollections.OrderedDict and collections.Counter."},
{"term": "meta path finder", "gloss": "A finder returned by a search of sys.meta_path.  Meta path\nfinders are related to, but different from path entry finders.\nSee importlib.abc.MetaPathFinder for the methods that meta path\nfinders implement.\n"},
{"term": "metaclass", "gloss": "The class of a class.  Class definitions create a class name, a class\ndictionary, and a list of base classes.  The metaclass is responsible for\ntaking those three arguments and creating the class.  Most object oriented\nprogramming languages provide a default implementation.  What makes Python\nspecial is that it is possible to create custom metaclasses.  Most users\nnever need this tool, but when the need arises, metaclasses can provide\npowerful, elegant solutions.  They have been used for logging attribute\naccess, adding thread-safety, tracking object creation, implementing\nsingletons, and many other tasks.\nMore information can be found in Metaclasses.\n"},
{"term": "method", "gloss": "A function which is defined inside a class body.  If called as an attribute\nof an instance of that class, the method will get the instance object as\nits first argument (which is usually called self).\nSee function and nested scope."},
{"term": "method resolution order", "gloss": "Method Resolution Order is the order in which base classes are searched\nfor a member during lookup. See The Python 2.3 Method Resolution Order for details of the\nalgorithm used by the Python interpreter since the 2.3 release."},
{"term": "module", "gloss": "An object that serves as an organizational unit of Python code.  Modules\nhave a namespace containing arbitrary Python objects.  Modules are loaded\ninto Python by the process of importing.\nSee also package.\n"},
{"term": "module spec", "gloss": "A namespace containing the import-related information used to load a\nmodule. An instance of importlib.machinery.ModuleSpec."},
{"term": "MRO", "gloss": "See method resolution order."},
{"term": "mutable", "gloss": "Mutable objects can change their value but keep their id().  See\nalso immutable."},
{"term": "named tuple", "gloss": "Any tuple-like class whose indexable elements are also accessible using\nnamed attributes (for example, time.localtime() returns a\ntuple-like object where the year is accessible either with an\nindex such as t[0] or with a named attribute like t.tm_year).\nA named tuple can be a built-in type such as time.struct_time,\nor it can be created with a regular class definition.  A full featured\nnamed tuple can also be created with the factory function\ncollections.namedtuple().  The latter approach automatically\nprovides extra features such as a self-documenting representation like\nEmployee(name='jones', title='programmer').\n"},
{"term": "namespace", "gloss": "The place where a variable is stored.  Namespaces are implemented as\ndictionaries.  There are the local, global and built-in namespaces as well\nas nested namespaces in objects (in methods).  Namespaces support\nmodularity by preventing naming conflicts.  For instance, the functions\nbuiltins.open and os.open() are distinguished by\ntheir namespaces.  Namespaces also aid readability and maintainability by\nmaking it clear which module implements a function.  For instance, writing\nrandom.seed() or itertools.islice() makes it clear that those\nfunctions are implemented by the random and itertools\nmodules, respectively."},
{"term": "namespace package", "gloss": "A PEP 420 package which serves only as a container for\nsubpackages.  Namespace packages may have no physical representation,\nand specifically are not like a regular package because they\nhave no __init__.py file.\nSee also module.\n"},
{"term": "nested scope", "gloss": "The ability to refer to a variable in an enclosing definition.  For\ninstance, a function defined inside another function can refer to\nvariables in the outer function.  Note that nested scopes by default work\nonly for reference and not for assignment.  Local variables both read and\nwrite in the innermost scope.  Likewise, global variables read and write\nto the global namespace.  The nonlocal allows writing to outer\nscopes."},
{"term": "new-style class", "gloss": "Old name for the flavor of classes now used for all class objects.  In\nearlier Python versions, only new-style classes could use Python’s newer,\nversatile features like __slots__, descriptors,\nproperties, __getattribute__(), class methods, and static methods."},
{"term": "object", "gloss": "Any data with state (attributes or value) and defined behavior\n(methods).  Also the ultimate base class of any new-style\nclass."},
{"term": "package", "gloss": "A Python module which can contain submodules or recursively,\nsubpackages.  Technically, a package is a Python module with an\n__path__ attribute.\nSee also regular package and namespace package.\n"},
{"term": "parameter", "gloss": "A named entity in a function (or method) definition that\nspecifies an argument (or in some cases, arguments) that the\nfunction can accept.  There are five kinds of parameter:\n\npositional-or-keyword: specifies an argument that can be passed\neither positionally or as a keyword argument.  This is the default kind of parameter, for example foo\nand bar in the following:\ndef func(foo, bar=None): ...\n\n\n\n\n\npositional-only: specifies an argument that can be supplied only\nby position.  Python has no syntax for defining positional-only\nparameters.  However, some built-in functions have positional-only\nparameters (e.g. abs()).\n\n\nkeyword-only: specifies an argument that can be supplied only\nby keyword.  Keyword-only parameters can be defined by including a\nsingle var-positional parameter or bare * in the parameter list\nof the function definition before them, for example kw_only1 and\nkw_only2 in the following:\ndef func(arg, *, kw_only1, kw_only2): ...\n\n\n\nvar-positional: specifies that an arbitrary sequence of\npositional arguments can be provided (in addition to any positional\narguments already accepted by other parameters).  Such a parameter can\nbe defined by prepending the parameter name with *, for example\nargs in the following:\ndef func(*args, **kwargs): ...\n\n\n\nvar-keyword: specifies that arbitrarily many keyword arguments\ncan be provided (in addition to any keyword arguments already accepted\nby other parameters).  Such a parameter can be defined by prepending\nthe parameter name with **, for example kwargs in the example\nabove.\n\n\nParameters can specify both optional and required arguments, as well as\ndefault values for some optional arguments.\nSee also the argument glossary entry, the FAQ question on\nthe difference between arguments and parameters, the inspect.Parameter class, the\nFunction definitions section, and PEP 362.\n"},
{"term": "path entry", "gloss": "A single location on the import path which the path\nbased finder consults to find modules for importing."},
{"term": "path entry finder", "gloss": "A finder returned by a callable on sys.path_hooks\n(i.e. a path entry hook) which knows how to locate modules given\na path entry.\nSee importlib.abc.PathEntryFinder for the methods that path entry\nfinders implement.\n"},
{"term": "path entry hook", "gloss": "A callable on the sys.path_hook list which returns a path\nentry finder if it knows how to find modules on a specific path\nentry."},
{"term": "path based finder", "gloss": "One of the default meta path finders which\nsearches an import path for modules."},
{"term": "path-like object", "gloss": "An object representing a file system path. A path-like object is either\na str or bytes object representing a path, or an object\nimplementing the os.PathLike protocol. An object that supports\nthe os.PathLike protocol can be converted to a str or\nbytes file system path by calling the os.fspath() function;\nos.fsdecode() and os.fsencode() can be used to guarantee a\nstr or bytes result instead, respectively. Introduced\nby PEP 519."},
{"term": "PEP", "gloss": "Python Enhancement Proposal. A PEP is a design document\nproviding information to the Python community, or describing a new\nfeature for Python or its processes or environment. PEPs should\nprovide a concise technical specification and a rationale for proposed\nfeatures.\nPEPs are intended to be the primary mechanisms for proposing major new\nfeatures, for collecting community input on an issue, and for documenting\nthe design decisions that have gone into Python. The PEP author is\nresponsible for building consensus within the community and documenting\ndissenting opinions.\nSee PEP 1.\n"},
{"term": "portion", "gloss": "A set of files in a single directory (possibly stored in a zip file)\nthat contribute to a namespace package, as defined in PEP 420."},
{"term": "positional argument", "gloss": "See argument."},
{"term": "provisional API", "gloss": "A provisional API is one which has been deliberately excluded from\nthe standard library’s backwards compatibility guarantees.  While major\nchanges to such interfaces are not expected, as long as they are marked\nprovisional, backwards incompatible changes (up to and including removal\nof the interface) may occur if deemed necessary by core developers.  Such\nchanges will not be made gratuitously – they will occur only if serious\nfundamental flaws are uncovered that were missed prior to the inclusion\nof the API.\nEven for provisional APIs, backwards incompatible changes are seen as\na “solution of last resort” - every attempt will still be made to find\na backwards compatible resolution to any identified problems.\nThis process allows the standard library to continue to evolve over\ntime, without locking in problematic design errors for extended periods\nof time.  See PEP 411 for more details.\n"},
{"term": "provisional package", "gloss": "See provisional API."},
{"term": "Python 3000", "gloss": "Nickname for the Python 3.x release line (coined long ago when the\nrelease of version 3 was something in the distant future.)  This is also\nabbreviated “Py3k”."},
{"term": "Pythonic", "gloss": "An idea or piece of code which closely follows the most common idioms\nof the Python language, rather than implementing code using concepts\ncommon to other languages.  For example, a common idiom in Python is\nto loop over all elements of an iterable using a for\nstatement.  Many other languages don’t have this type of construct, so\npeople unfamiliar with Python sometimes use a numerical counter instead:\nfor i in range(len(food)):\n    print(food[i])\n\n\nAs opposed to the cleaner, Pythonic method:\nfor piece in food:\n    print(piece)\n\n\n"},
{"term": "qualified name", "gloss": "A dotted name showing the “path” from a module’s global scope to a\nclass, function or method defined in that module, as defined in\nPEP 3155.  For top-level functions and classes, the qualified name\nis the same as the object’s name:\n>>> class C:\n...     class D:\n...         def meth(self):\n...             pass\n...\n>>> C.__qualname__\n'C'\n>>> C.D.__qualname__\n'C.D'\n>>> C.D.meth.__qualname__\n'C.D.meth'\n\n\nWhen used to refer to modules, the fully qualified name means the\nentire dotted path to the module, including any parent packages,\ne.g. email.mime.text:\n>>> import email.mime.text\n>>> email.mime.text.__name__\n'email.mime.text'\n\n\n"},
{"term": "reference count", "gloss": "The number of references to an object.  When the reference count of an\nobject drops to zero, it is deallocated.  Reference counting is\ngenerally not visible to Python code, but it is a key element of the\nCPython implementation.  The sys module defines a\ngetrefcount() function that programmers can call to return the\nreference count for a particular object."},
{"term": "regular package", "gloss": "A traditional package, such as a directory containing an\n__init__.py file.\nSee also namespace package.\n"},
{"term": "__slots__", "gloss": "A declaration inside a class that saves memory by pre-declaring space for\ninstance attributes and eliminating instance dictionaries.  Though\npopular, the technique is somewhat tricky to get right and is best\nreserved for rare cases where there are large numbers of instances in a\nmemory-critical application."},
{"term": "sequence", "gloss": "An iterable which supports efficient element access using integer\nindices via the __getitem__() special method and defines a\n__len__() method that returns the length of the sequence.\nSome built-in sequence types are list, str,\ntuple, and bytes. Note that dict also\nsupports __getitem__() and __len__(), but is considered a\nmapping rather than a sequence because the lookups use arbitrary\nimmutable keys rather than integers.\nThe collections.abc.Sequence abstract base class\ndefines a much richer interface that goes beyond just\n__getitem__() and __len__(), adding count(),\nindex(), __contains__(), and\n__reversed__(). Types that implement this expanded\ninterface can be registered explicitly using\nregister().\n"},
{"term": "single dispatch", "gloss": "A form of generic function dispatch where the implementation is\nchosen based on the type of a single argument."},
{"term": "slice", "gloss": "An object usually containing a portion of a sequence.  A slice is\ncreated using the subscript notation, [] with colons between numbers\nwhen several are given, such as in variable_name[1:3:5].  The bracket\n(subscript) notation uses slice objects internally."},
{"term": "special method", "gloss": "A method that is called implicitly by Python to execute a certain\noperation on a type, such as addition.  Such methods have names starting\nand ending with double underscores.  Special methods are documented in\nSpecial method names."},
{"term": "statement", "gloss": "A statement is part of a suite (a “block” of code).  A statement is either\nan expression or one of several constructs with a keyword, such\nas if, while or for."},
{"term": "struct sequence", "gloss": "A tuple with named elements. Struct sequences expose an interface similar\nto named tuple in that elements can either be accessed either by\nindex or as an attribute. However, they do not have any of the named tuple\nmethods like _make() or\n_asdict(). Examples of struct sequences\ninclude sys.float_info and the return value of os.stat()."},
{"term": "text encoding", "gloss": "A codec which encodes Unicode strings to bytes."},
{"term": "text file", "gloss": "A file object able to read and write str objects.\nOften, a text file actually accesses a byte-oriented datastream\nand handles the text encoding automatically.\nExamples of text files are files opened in text mode ('r' or 'w'),\nsys.stdin, sys.stdout, and instances of\nio.StringIO.\n\nSee also\nA binary file reads and write bytes objects.\n\n"},
{"term": "triple-quoted string", "gloss": "A string which is bound by three instances of either a quotation mark\n(“) or an apostrophe (‘).  While they don’t provide any functionality\nnot available with single-quoted strings, they are useful for a number\nof reasons.  They allow you to include unescaped single and double\nquotes within a string and they can span multiple lines without the\nuse of the continuation character, making them especially useful when\nwriting docstrings."},
{"term": "type", "gloss": "The type of a Python object determines what kind of object it is; every\nobject has a type.  An object’s type is accessible as its\n__class__ attribute or can be retrieved with\ntype(obj)."},
{"term": "universal newlines", "gloss": "A manner of interpreting text streams in which all of the following are\nrecognized as ending a line: the Unix end-of-line convention '\\n',\nthe Windows convention '\\r\\n', and the old Macintosh convention\n'\\r'.  See PEP 278 and PEP 3116, as well as\nbytes.splitlines() for an additional use."},
{"term": "variable annotation", "gloss": "A type metadata value associated with a module global variable or\na class attribute. Its syntax is explained in section Annotated assignment statements.\nAnnotations are stored in the __annotations__ special\nattribute of a class or module object and can be accessed using\ntyping.get_type_hints().\nPython itself does not assign any particular meaning to variable\nannotations. They are intended to be interpreted by third-party libraries\nor type checking tools. See PEP 526, PEP 484 which describe\nsome of their potential uses.\n"},
{"term": "virtual environment", "gloss": "A cooperatively isolated runtime environment that allows Python users\nand applications to install and upgrade Python distribution packages\nwithout interfering with the behaviour of other Python applications\nrunning on the same system.\nSee also venv.\n"},
{"term": "virtual machine", "gloss": "A computer defined entirely in software.  Python’s virtual machine\nexecutes the bytecode emitted by the bytecode compiler."},
{"term": "Zen of Python", "gloss": "Listing of Python design principles and philosophies that are helpful in\nunderstanding and using the language.  The listing can be found by typing\n“import this” at the interactive prompt."}
]